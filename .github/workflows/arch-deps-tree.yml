name: arch-deps-tree

on:
  workflow_dispatch:
  push:
    paths:
      - pkglist.txt
      - .github/workflows/arch-deps-tree.yml

jobs:
  deps:
    runs-on: ubuntu-latest

    container:
      image: archlinux:base-devel

    defaults:
      run:
        shell: bash

    steps:
      - uses: actions/checkout@v6

      - name: Init keyring + tools
        run: |
          pacman-key --init
          pacman -Sy --noconfirm archlinux-keyring
          pacman -Syu --noconfirm
          pacman -S --noconfirm pacman-contrib
          pacman -S --noconfirm python

      - name: Generate dedup tree + summary at end
        run: |
          cat > arch_tree.py <<'PY'
          import re, sys, subprocess
          from collections import defaultdict

          PKGLIST = sys.argv[1]
          OUT = "deps.tree.txt"

          # Em alguns ambientes/versões, o -g pode incluir nós sintéticos no graphviz
          SYNTHETIC = {"START", "END"}

          def read_pkglist(path):
              pkgs = []
              for line in open(path, "r", encoding="utf-8"):
                  line = line.strip()
                  if not line or line.startswith("#"):
                      continue
                  pkgs.append(line)
              return pkgs

          roots = read_pkglist(PKGLIST)
          explicit = set(roots)

          # Build dependency edges using pactree's graph output
          edge_re = re.compile(r'"([^"]+)"\s*->\s*"([^"]+)"')
          deps = defaultdict(set)    # a -> {b,c}
          rdeps = defaultdict(set)   # b -> {a,...} (quem puxa b diretamente)

          for r in roots:
              p = subprocess.run(["pactree", "-s", "-g", r], text=True, capture_output=True)
              if p.returncode != 0:
                  print(f"# ERROR pactree failed for {r}: {p.stderr.strip()}", file=sys.stderr)
                  continue

              for a, b in edge_re.findall(p.stdout):
                  if a in SYNTHETIC or b in SYNTHETIC:
                      continue
                  deps[a].add(b)
                  rdeps[b].add(a)

          # Reachability per root (para saber quais roots puxam um pacote, direta/indiretamente)
          def reachable(start):
              seen = set()
              stack = [start]
              while stack:
                  cur = stack.pop()
                  for ch in deps.get(cur, ()):
                      if ch not in seen:
                          seen.add(ch)
                          stack.append(ch)
              return seen

          reach = {r: reachable(r) for r in roots}

          # Encontra 1 caminho exemplo root -> ... -> target (para visualização)
          def find_any_path(start, target):
              stack = [(start, [start])]
              seen = set()
              while stack:
                  cur, path = stack.pop()
                  if cur == target:
                      return path
                  if cur in seen:
                      continue
                  seen.add(cur)
                  for ch in deps.get(cur, ()):
                      if ch in path:
                          continue
                      stack.append((ch, path + [ch]))
              return None

          def fmt_path(path):
              if not path:
                  return None
              if len(path) > 10:
                  return " -> ".join(path[:3] + ["..."] + path[-2:])
              return " -> ".join(path)

          def sort_parents(parents):
              # roots (da sua lista) primeiro, depois o resto; ambos em ordem alfabética
              return sorted(parents, key=lambda x: (0 if x in explicit else 1, x))

          # Escreve em UTF-8 com BOM para não “quebrar” em viewers que assumem ANSI
          with open(OUT, "w", encoding="utf-8-sig", newline="\n") as out:
              def o(s=""):
                  print(s, file=out)

              # ---------- Tree printing ----------
              expanded = set()

              def node_label(name, is_root=False):
                  tags = []
                  if name in explicit:
                      tags.append("explicit")
                  if is_root:
                      tags.append("root")
                  return name + ("" if not tags else " " + " ".join(f"[{t}]" for t in tags))

              def print_subtree(pkg, prefix, is_last, stack):
                  branch = "└── " if is_last else "├── "
                  cont_prefix = "    " if is_last else "│   "

                  if pkg in stack:
                      o(prefix + branch + f"{pkg} [cycle]")
                      return

                  # explicit como dependência: mostra e marca [explicit] [ref], não expande aqui
                  if pkg in explicit:
                      o(prefix + branch + f"{pkg} [explicit] [ref]")
                      return

                  # dedupe global: não-explicit só expande 1x
                  if pkg in expanded:
                      o(prefix + branch + f"{pkg} [ref]")
                      return

                  o(prefix + branch + pkg)
                  expanded.add(pkg)

                  children = sorted(deps.get(pkg, ()))
                  if not children:
                      return

                  new_stack = set(stack)
                  new_stack.add(pkg)

                  for i, ch in enumerate(children):
                      last = (i == len(children) - 1)
                      print_subtree(ch, prefix + cont_prefix, last, new_stack)

              # Forest
              for r in roots:
                  o(node_label(r, is_root=True))
                  children = sorted(deps.get(r, ()))
                  for j, ch in enumerate(children):
                      print_subtree(ch, "", j == len(children) - 1, set([r]))
                  o()

              # ---------- Summary ----------
              o("# ===== Resumo (pkglist) =====")
              o("# A) Pacotes da sua lista que aparecem como dependência de OUTROS pacotes da lista (candidatos a remover):")

              redundant = []
              for p in roots:
                  roots_that_pull = sorted(r for r in roots if r != p and p in reach.get(r, set()))
                  if roots_that_pull:
                      redundant.append((p, roots_that_pull))

              if redundant:
                  for p, roots_that_pull in sorted(redundant, key=lambda x: x[0]):
                      parents_raw = [x for x in rdeps.get(p, set()) if x not in SYNTHETIC and x != p]
                      parents = sort_parents(parents_raw)

                      o(f"# - {p}")
                      o(f"#   puxado por (roots da lista): {', '.join(roots_that_pull)}")

                      # “mesmo que seja dependência”: aqui entram TODOS os pais diretos (roots ou deps intermediárias)
                      if parents:
                          o(f"#   puxado diretamente por: {', '.join(parents)}")

                      # 1 caminho exemplo PARA CADA root que puxa
                      for r in roots_that_pull:
                          path = find_any_path(r, p)
                          if path:
                              o(f"#   exemplo ({r}): {fmt_path(path)}")

                      o("#")
              else:
                  o("#   (nenhum)")
              o()

              o("# B) Pacotes da sua lista que NÃO aparecem como dependência de nada (no grafo gerado):")
              not_pulled = []
              for p in roots:
                  parents_raw = [x for x in rdeps.get(p, set()) if x not in SYNTHETIC and x != p]
                  if not parents_raw:
                      not_pulled.append(p)

              if not_pulled:
                  for p in sorted(not_pulled):
                      o(f"# - {p}")
              else:
                  o("#   (nenhum)")
          PY

          python arch_tree.py pkglist.txt
          cat deps.tree.txt

      - name: Upload report
        uses: actions/upload-artifact@v6
        with:
          name: arch-deps-tree
          path: deps.tree.txt
