name: arch-deps-tree

on:
  workflow_dispatch:
  push:
    paths:
      - pkglist.txt
      - .github/workflows/arch-deps-tree.yml

jobs:
  deps:
    runs-on: ubuntu-latest

    container:
      image: archlinux:base-devel

    defaults:
      run:
        shell: bash

    steps:
      - uses: actions/checkout@v6

      - name: Init keyring + tools
        run: |
          pacman-key --init
          pacman -Sy --noconfirm archlinux-keyring
          pacman -Syu --noconfirm

          pacman -S --noconfirm pacman-contrib

          pacman -S --noconfirm python

      - name: Generate dedup tree + summary at end
        run: |
          cat > arch_tree.py <<'PY'
          import re, sys, subprocess
          from collections import defaultdict

          PKGLIST = sys.argv[1]

          def read_pkglist(path):
              pkgs = []
              for line in open(path, "r", encoding="utf-8"):
                  line = line.strip()
                  if not line or line.startswith("#"):
                      continue
                  pkgs.append(line)
              return pkgs

          roots = read_pkglist(PKGLIST)
          explicit = set(roots)

          # Build dependency edges using pactree's graph output
          # pactree -g: Graphviz; pactree -s: sync db
          edge_re = re.compile(r'"([^"]+)"\s*->\s*"([^"]+)"')
          deps = defaultdict(set)   # a -> {b,c}
          rdeps = defaultdict(set)  # b -> {a,...}  (who pulls b directly)

          for r in roots:
              p = subprocess.run(["pactree", "-s", "-g", r], text=True, capture_output=True)
              if p.returncode != 0:
                  print(f"# ERROR pactree failed for {r}: {p.stderr.strip()}", file=sys.stderr)
                  continue
              for a, b in edge_re.findall(p.stdout):
                  deps[a].add(b)
                  rdeps[b].add(a)

          # Reachability per root (to know which roots ultimately pull a package)
          def reachable(start):
              seen = set()
              stack = [start]
              while stack:
                  cur = stack.pop()
                  for ch in deps.get(cur, ()):
                      if ch not in seen:
                          seen.add(ch)
                          stack.append(ch)
              return seen

          reach = {r: reachable(r) for r in roots}

          # Find one example path root -> ... -> target (for nicer reporting)
          def find_any_path(start, target):
              stack = [(start, [start])]
              seen = set()
              while stack:
                  cur, path = stack.pop()
                  if cur == target:
                      return path
                  if cur in seen:
                      continue
                  seen.add(cur)
                  for ch in deps.get(cur, ()):
                      if ch in path:
                          continue
                      stack.append((ch, path + [ch]))
              return None

          # Tree printing:
          # - expand each non-explicit package only once globally
          # - show explicit packages wherever they appear (tagged), but don't re-expand them as deps
          expanded = set()

          def node_label(name, is_root=False):
              tags = []
              if name in explicit:
                  tags.append("explicit")
              if is_root:
                  tags.append("root")
              return name + ("" if not tags else " " + " ".join(f"[{t}]" for t in tags))

          def print_subtree(pkg, prefix, is_last, stack):
              branch = "└── " if is_last else "├── "
              cont_prefix = "    " if is_last else "│   "

              # avoid cycles
              if pkg in stack:
                  print(prefix + branch + f"{pkg} [cycle]")
                  return

              # If pkg is explicit AND it's not the root we are currently printing,
              # print it (so you notice it was in your list), but don't expand here.
              # Mark also as [ref] so it is easy to filter.
              if pkg in explicit:
                  print(prefix + branch + f"{pkg} [explicit] [ref]")
                  return

              # Non-explicit: expand only once globally; later occurrences become a reference line
              if pkg in expanded:
                  print(prefix + branch + f"{pkg} [ref]")
                  return

              print(prefix + branch + pkg)
              expanded.add(pkg)

              children = sorted(deps.get(pkg, ()))
              if not children:
                  return

              new_stack = set(stack)
              new_stack.add(pkg)

              for i, ch in enumerate(children):
                  last = (i == len(children) - 1)
                  print_subtree(ch, prefix + cont_prefix, last, new_stack)

          # Print forest
          for r in roots:
              print(node_label(r, is_root=True))
              children = sorted(deps.get(r, ()))
              for j, ch in enumerate(children):
                  print_subtree(ch, "", j == len(children) - 1, set([r]))
              print()

          # ---- Summary section (same file, clearer & cohesive) ----
          # Explicit packages that appear as dependency of *something* in the collected graph:
          # i.e., have at least one direct parent (incoming edge)
          pulled = []
          not_pulled = []

          for p in roots:
              parents = sorted(x for x in rdeps.get(p, set()) if x != p)
              if parents:
                  pulled.append(p)
              else:
                  not_pulled.append(p)

          def fmt_path(path):
              if not path:
                  return None
              if len(path) > 10:
                  return " -> ".join(path[:3] + ["..."] + path[-2:])
              return " -> ".join(path)

          if pulled:
              print("# Pacotes da sua lista que aparecem como dependência (quem puxa):")
              for p in sorted(pulled):
                  parents = sorted(x for x in rdeps.get(p, set()) if x != p)
                  roots_that_pull = sorted(r for r in roots if r != p and p in reach.get(r, set()))

                  print(f"# - {p}")
                  if parents:
                      print(f"#   puxado diretamente por: {', '.join(parents)}")
                  if roots_that_pull:
                      print(f"#   (via roots da lista): {', '.join(roots_that_pull)}")
                      # mostra um exemplo de caminho (só 1) pra ficar legível
                      ex_root = roots_that_pull[0]
                      path = find_any_path(ex_root, p)
                      if path:
                          print(f"#   exemplo: {fmt_path(path)}")
                  print("#")

          if not_pulled:
              print("# Pacotes da sua lista que NÃO aparecem como dependência de nada (no grafo gerado):")
              for p in sorted(not_pulled):
                  print(f"# - {p}")
          PY

          python arch_tree.py pkglist.txt > deps.tree.txt
          cat deps.tree.txt

      - name: Upload report
        uses: actions/upload-artifact@v6
        with:
          name: arch-deps-tree
          path: deps.tree.txt
