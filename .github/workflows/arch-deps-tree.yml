name: arch-deps-tree

on:
  workflow_dispatch:
  push:
    paths:
      - pkglist.txt
      - .github/workflows/arch-deps-tree.yml

jobs:
  deps:
    runs-on: ubuntu-latest

    container:
      image: archlinux:base-devel

    defaults:
      run:
        shell: bash

    steps:
      - uses: actions/checkout@v6

      - name: Init keyring + tools
        run: |
          set -euo pipefail

          pacman-key --init
          pacman-key --populate archlinux

          pacman -Sy --noconfirm archlinux-keyring
          pacman -Syu --noconfirm --needed

          # pactree
          pacman -S --noconfirm --needed pacman-contrib

          pacman -S --noconfirm --needed python

      - name: Generate tree + redundant report + minimal pkglist
        run: |
          set -euo pipefail

          cat > arch_tree.py <<'PY'
          import re, sys, subprocess
          from collections import defaultdict

          PKGLIST_PATH = sys.argv[1]

          OUT_TREE = "deps.tree.txt"
          OUT_REDUNDANT = "redundant.tsv"
          OUT_MIN = "pkglist.min.txt"

          def read_pkglist(path):
              pkgs = []
              for line in open(path, "r", encoding="utf-8"):
                  s = line.strip()
                  if not s or s.startswith("#"):
                      continue
                  pkgs.append(s)
              return pkgs

          def load_pkglist_lines(path):
              # Preserva comentários/linhas vazias para possibilitar gerar um "min" mais legível
              return open(path, "r", encoding="utf-8").read().splitlines()

          roots = read_pkglist(PKGLIST_PATH)
          explicit = set(roots)

          # Build dependency edges using pactree's graph output
          edge_re = re.compile(r'"([^"]+)"\s*->\s*"([^"]+)"')
          deps = defaultdict(set)   # a -> {b,c}
          rdeps = defaultdict(set)  # b -> {a,...}

          for r in roots:
              p = subprocess.run(["pactree", "-s", "-g", r], text=True, capture_output=True)
              if p.returncode != 0:
                  print(f"# ERROR pactree failed for {r}: {p.stderr.strip()}", file=sys.stderr)
                  continue
              for a, b in edge_re.findall(p.stdout):
                  deps[a].add(b)
                  rdeps[b].add(a)

          def reachable(start):
              seen = set()
              stack = [start]
              while stack:
                  cur = stack.pop()
                  for ch in deps.get(cur, ()):
                      if ch not in seen:
                          seen.add(ch)
                          stack.append(ch)
              return seen

          reach = {r: reachable(r) for r in roots}

          # pkg is "redundant" if some other root reaches it (directly or indirectly)
          redundant_roots = {}
          for p in roots:
              pulled_by_roots = sorted(r for r in roots if r != p and p in reach.get(r, set()))
              if pulled_by_roots:
                  redundant_roots[p] = pulled_by_roots

          redundant_set = set(redundant_roots.keys())

          # Find one example path root -> ... -> target (for reporting)
          def find_any_path(start, target):
              stack = [(start, [start])]
              seen = set()
              while stack:
                  cur, path = stack.pop()
                  if cur == target:
                      return path
                  if cur in seen:
                      continue
                  seen.add(cur)
                  for ch in deps.get(cur, ()):
                      if ch in path:
                          continue
                      stack.append((ch, path + [ch]))
              return None

          # ---------- Write tree ----------
          expanded = set()

          def fmt(name, tags=()):
              if tags:
                  return f"{name} " + " ".join(f"[{t}]" for t in tags)
              return name

          def write_tree():
              with open(OUT_TREE, "w", encoding="utf-8") as f:
                  def w(line=""):
                      f.write(line + "\n")

                  def print_subtree(pkg, prefix, is_last, stack):
                      branch = "└── " if is_last else "├── "
                      cont_prefix = "    " if is_last else "│   "

                      if pkg in stack:
                          w(prefix + branch + fmt(pkg, ("cycle",)))
                          return

                      # Explicit package appearing as dependency: show it and mark [explicit] [ref]
                      # (ref = não expandimos aqui)
                      if pkg in explicit:
                          w(prefix + branch + fmt(pkg, ("explicit", "ref")))
                          return

                      # Non-explicit: expand only once globally; later occurrences are [ref]
                      if pkg in expanded:
                          w(prefix + branch + fmt(pkg, ("ref",)))
                          return

                      w(prefix + branch + pkg)
                      expanded.add(pkg)

                      children = sorted(deps.get(pkg, ()))
                      if not children:
                          return

                      new_stack = set(stack)
                      new_stack.add(pkg)

                      for i, ch in enumerate(children):
                          last = (i == len(children) - 1)
                          print_subtree(ch, prefix + cont_prefix, last, new_stack)

                  for r in roots:
                      w(fmt(r, ("explicit", "root")))
                      children = sorted(deps.get(r, ()))
                      for j, ch in enumerate(children):
                          print_subtree(ch, "", j == len(children) - 1, set([r]))
                      w()

          write_tree()

          # ---------- Write redundant TSV report ----------
          with open(OUT_REDUNDANT, "w", encoding="utf-8") as f:
              f.write("pkg\tpulled_by_roots\tdirect_parents\texample_paths\n")
              for pkg in sorted(redundant_roots.keys()):
                  roots_that_pull = redundant_roots[pkg]
                  direct_parents = sorted(rdeps.get(pkg, ()))

                  paths = []
                  for r in roots_that_pull:
                      path = find_any_path(r, pkg)
                      if path:
                          # comprime path muito longo
                          if len(path) > 10:
                              path_str = " -> ".join(path[:3] + ["..."] + path[-2:])
                          else:
                              path_str = " -> ".join(path)
                          paths.append(path_str)

                  f.write(
                      pkg + "\t" +
                      ",".join(roots_that_pull) + "\t" +
                      ",".join(direct_parents) + "\t" +
                      " | ".join(paths) +
                      "\n"
                  )

          # ---------- Write minimal pkglist (remove redundants) ----------
          # Mantém comentários e linhas vazias; remove apenas linhas de pacote redundante.
          in_lines = load_pkglist_lines(PKGLIST_PATH)
          out_lines = []
          for line in in_lines:
              s = line.strip()
              if not s or s.startswith("#"):
                  out_lines.append(line)
                  continue
              if s in redundant_set:
                  # removendo de fato (lista mínima)
                  continue
              out_lines.append(line)

          with open(OUT_MIN, "w", encoding="utf-8") as f:
              f.write("\n".join(out_lines).rstrip() + "\n")

          print("== deps.tree.txt ==")
          print(open(OUT_TREE, "r", encoding="utf-8").read())

          print("== redundant.tsv ==")
          print(open(OUT_REDUNDANT, "r", encoding="utf-8").read())

          print("== pkglist.min.txt ==")
          print(open(OUT_MIN, "r", encoding="utf-8").read())
          PY

          python arch_tree.py pkglist.txt

      - name: Upload report(s)
        uses: actions/upload-artifact@v6
        with:
          name: arch-deps-tree
          path: |
            deps.tree.txt
            redundant.tsv
            pkglist.min.txt
